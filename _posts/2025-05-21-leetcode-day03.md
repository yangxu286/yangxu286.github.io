---
title: Leetcode Day03：二分+贪心
date: 2025-05-21 21:11:00 +0800
tags: [算法, Leetcode, 二分, 贪心]
categories: [算法]
---
注：为随手写的刷题笔记，请谨慎参考，欢迎指出错漏。
### 二分（续）

今天把旧书（《算法竞赛进阶指南》）翻出来看，里面对二分的讲解感觉很不错。我自己总结如下：

书上主张的写法保证最终答案始终处于闭区间[l,r]之内，当l=r时循环结束，区间总是会缩小到确切答案上，非常优美。而缩小区间时要考虑的问题也非常清楚：保证答案在区间内。

书上给出两种形式：

* 在单增序列中查找>=x的数中最小的一个

  ```c++
  while(l < r){
  	int mid = (l + r) >> 1;
  	if(a[mid] >= x) r = mid; else l = mid + 1;
  }
  return a[l];
  ```

  因为查找>=x的数，所以mid满足>=x时，缩小就需要把mid包含在内；否则，mid不满足，就不包含在内。

* 在单增序列中查找<=x的数中最大的一个

  ```c++
  while(l < r){
  	int mid = (l + r + 1) >> 1;
  	if(a[mid] <= x) l = mid; else r = mid - 1;
  }
  return a[l];
  ```

  因为查找<=x的数，所以mid满足<=x时，缩小就需要把mid包含在内；否则，mid不满足，就不包含在内。

另外的不同就是mid的取值上。首先使用的都是右移运算，这是因为**右移运算向下取整，整数除法向0取整，使用整数除法会在值域包含负数时出错**。

然后是地板除还是天花板除。这里其实可以死记，找右端点靠右边取，找左端点靠左边取。至于原因，就是r-l=1时可能会产生死循环，具体看书P26。



### 贪心

#### 121.买卖股票的最佳时机

我想的是先从后往前找，更新并存储第i天及以后的最高卖出价，然后再遍历每一天计算今天买下可以得到的最高利润。

这样能过，但是空间复杂度不好，实际上从前往后找，只需要用一个数更新直到这一天的最低买入价，然后再计算今天卖出可以得到的最高利润即可。如果今天买入价最低，那么一定不是今天卖，所以可以直接跳过后面的计算。

总而言之我只想到“越早买，卖的选择越多”，没想到“越晚卖，买的选择越多”。

#### 55.跳跃游戏

比较简单的题目，遍历每一格，并维护能往前继续走的剩余格子数。

#### 45.跳跃游戏II

动态规划很显然：

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int len = nums.size();
        vector<int> f(len, 99999999);
        f[0] = 0;
        for(int i = 0; i < len; i++){
            for(int j = i + 1; j <= i + nums[i] && j < len; j++){
                f[j] = min(f[j], f[i] + 1);
            }
        }
        return f[len - 1];
    }
};
```

贪心的$O(n^2)$法也挺好想，从尾端往前找最靠前的一个跳跃点。

为什么是找最靠前的呢？简单不严谨证明一下：假如最靠前的跳跃点是a，跳到了一个不那么靠前的跳跃点b，b就是a后面一格。那么，能够跳到b的点一定也能跳到a。所以，选择a不会失去最优解。假如选择b后面的一格，那么显然下一步的选择更少，唯一可能增加了的选择就是b这一格，那不如直接跳到b……以此类推。

但最妙的还是$O(n)$的方法，正向寻找，但有一个很聪明的地方：从一个格子往后跳，跳到能够二次跳得最远的格子，就可以更新当前能够到达的最大下标位置。同时，有一个变量end随时待命，在每次抵达end后，都把步数+1，然后end更新为当前能够到达的最大下标位置。这样就可以做到一旦脱离“上一次跳的最大范围”，马上+1步数并进入“下一次跳的最大范围”。（还是有一点点抽象）

值得一提的是我也想到了类似的做法，但我只想到了用队列来更新每个格子的“掌控范围”以正确更新步数。

以下为官方题解代码：

```c++
class Solution {
public:
    int jump(vector<int>& nums) {
        int maxPos = 0, n = nums.size(), end = 0, step = 0;
        for (int i = 0; i < n - 1; ++i) {
            if (maxPos >= i) {
                maxPos = max(maxPos, i + nums[i]);
                if (i == end) {
                    end = maxPos;
                    ++step;
                }
            }
        }
        return step;
    }
};
```



