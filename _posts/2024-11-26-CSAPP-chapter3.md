---
title: ICS CSAPP第三章笔记（补天速记版）
date: 2024-11-26 10:32:49 +0800
tags: [ICS, CSAPP]
categories: [ICS]
math: true
---

#### 寻址模式

只需记：`Imm(rb,ri,s)`相当于rb+s*ri+Imm。

#### mov_

源操作数是一个立即数，存储在寄存器中或者内存中。目的操作数则指定一个位置，是寄存器或内存地址。

当目的比源小或等同时，无需加上z或s这种扩展指示符。b/w/l/q指示符有一套选取标准：

* 如果有(%rbp)这种内存地址操作数，暂时忽略它，因为我们看不出它的大小。由于两个操作数都是内存的情况被禁止了，总能找到一个确定的选取大小指示符的依据。
* 根据剩下的操作数判断选择b/w/l/q。
* 如果有如\$0x4050这种立即数，也可以视作比它更大的源，在这个例子中可以是双字或四字，因为它会被汇编器自动进行扩展。所以`movl $0x4050,%eax`不会报错。

由于可以自由调节使用寄存器的范围（如%rax，%eax，%ax，%al），大小指示符和（能直接读出的）源和目的的大小必须匹配，否则会报错。

当目的比源大时，则需写明源和目的各自的大小，以及扩展方式（零扩展z和符号扩展s）。

需要特别注意：不存在`movzlq`，这种功能可以用`movl`实现，因为生成4字节值并以寄存器作为目的的指令会把高4字节置为0；存在无操作数的快捷指令`cltq`，效果与`movslq %eax,%rax`一致。

`movzbl`不仅会清零%e\_\_中的高3个字节，还会把整个寄存器%r\_\_的高4个字节清零。

另外，对寄存器中存储的内存地址进行寻址时，肯定不能用(%ebx)这种不完整的方式。

#### 栈

%rsp内存储的是栈的指针。`pushq S`中S为压入的数据源，`popq D`中D为弹出的数据目的。

栈向低地址方向增长，压栈操作会减小栈指针的值，即以下两部分指令等价：`pushq %rbp`和

```
subq $8,%rsp
movq %rbp,(%rsp)
```

弹栈操作会增加栈指针的值，即以下两部分指令等价：`popq %rax`和

```
movq (%rsp),%rax
addq $8,%rsp
```

可用标准寻址方法访问栈内任意位置，如`movq 8(%rsp),%rdx`可将第二个四字从栈中复制到寄存器%rdx。

#### 算术和逻辑操作

##### leaq

除了*将有效地址写入目的操作数*外，还可以执行加法和有限形式的乘法。

如`leaq (%rax,%rcx,4),%rdx`将%rax中值+%rcx中值*4存入了%rdx。

实际上，可以完全不考虑leaq的“存储地址”功能。因为整数既可以作为数字也可以作为地址，而leaq完全不会引用源中的寄存器，只会单纯进行计算操作，所以就可以把leaq看作一条计算指令。

##### 移位操作

对于移位操作的移位量（即第一个操作数），可以是一个立即数，或放在单字节寄存器%cl中（也仅能是这个特定的寄存器）。1个字节的移位量使得理论上最大移位量为255。

*移位操作对w位长的数据值进行操作，移位量是由%cl寄存器的低m位决定的，2^m=w，高位会被忽略。所以，当%cl的值为0xFF，salb会移7位，salw移15位，sall移31位，salq移63位。*

所以，移位操作的数据大小标识符不仅要匹配需要操作的数据，还会自动调整移动的最大位数。这很合理。

##### 八字系列操作

imulq除了正常双操作数的一种外，还有单操作数的另一种指令，以计算两个64位值的全128位乘积。imulq为补码乘法（有符号全乘法）。它要求一个参数在%rax中，另一个则为源操作数，最后乘积存放在%rdx（高64位）和%rax（低64位）中。

mulq则为无符号全乘法，其他相同。

clto无操作数，会自动把%rax中的数进行符号扩展成128位，存到%rdx和%rax中（也即读取%rax的符号位，并复制到%rdx的所有位）。对无符号的扩展，则把0复制过去，如`movl $0,%edx`。

相应地，有idivq和divq，会将128位%rdx和%rax共同存的数除以单个操作数，并将商存入%rax，余数存入%rdx。

从%rdx和%rax中存128位数据到某一地址，也要前8字节后8字节分开操作。

#### 条件码

CPU维护一组单个位的条件码寄存器，其根据最近算数或逻辑操作的属性进行更新。

| CF   | 进位标志，最近操作使最高位产生进位 |
| ---- | ---------------------------------- |
| ZF   | 零标志，最近的操作得出的结果为0    |
| SF   | 符号标志，最近操作得到的结果为负   |
| OF   | 溢出标志，最近操作导致一个补码溢出 |

可知计算操作会引起条件码的改变，不过也可以通过cmp和test指令设置条件码。其中cmp指令和sub指令具有一样的行为，结果会引起条件码变化，但不引起操作数所在寄存器改变；test指令和and指令有一样的行为，其他同理。需要注意，cmp指令是后一个操作数减去前一个操作数。

一般不会直接访问条件码，但有set指令可根据条件码的值对某个字节进行设置。set指令的后缀表示条件。如sete是相等/零时，即ZF为1时设为1，setne相反；sets是SF为1时设为1等。

特别注意对于比较大小的set，有符号数和无符号数有所区别。setg、setge、setl、setle都用到了(SF^OF)和ZF的组合。这是因为若有溢出，SF的意义就会相反，本来是SF为1则a<b，变成SF为0则a<b，而此时OF=1，故进行异或操作。

而对于无符号数，则无溢出带来的正负号影响，但有进位操作影响。所以无符号数seta、setae、setb、setbe都使用了CF和ZF的组合。可通过使用的test/cmp和set指令来判断被比较的数据类型。

#### 跳转指令

##### 无条件跳转

指令jmp为无条件跳转，其中又分为直接跳转和间接跳转。直接跳转需要给出对应的label，这意味着跳转目标必然作为是指令的一部分编码的。而间接跳转给的是一个寄存器或内存位置，从中读取跳转的目标。

##### 条件跳转

条件跳转指令为j后加条件后缀，条件后缀和set完全相同，如je，jne，jge等。条件跳转必然为直接跳转。

##### 跳转指令的目标如何编码

似乎明白了一丁点：某使用L2 L3等label写好后产生的.o格式文件经过反汇编后，产生的注释中可能出现jmp 8<loop+0x8>这种形式。在这句话中，后面的0x8就是严格的跳转目标的地址。不过，查看原本代码可发现它对应的代码如3: eb 03形式，第二个字节便是目标编码0x3。这个0x3是跳转目标相对跳转指令的**下一条指令**的地址的偏移。比如：

```
3: eb 03		jmp	8<loop+0x8>
5: 48 di f8		sar %rax
8: 48 85 c0		test %rax,%rax
```

jmp想跳转到test指令，而它的下一行sar指令的地址为0x5，所以0x3+0x5=0x8，正是它想要跳转的目标。

#### 条件分支

见书本，熟悉一些goto逻辑的模式即可。

#### 条件传送指令

为什么需要条件传送指令？大概了解：指令流水线的性质使得对跳转的错误预测对性能的消耗极大，而条件传送无需预测跳转。（具体见P146）

mov指令是无条件版，而cmov指令是条件版。它和mov一样有两个操作数：源寄存器或内存地址，和目的寄存器。当传送条件满足时，指令把源值复制到目的。

源和目的的值可以是16位、32位或64位，但不支持单字节。mov指令操作数的长度显式地编码于指令名，但由于汇编器可以从目标寄存器的名字推断**条件传送指令**的操作数长度，所以对所有的操作数长度都使用相同的指令名。

cmov指令的后缀和set指令相同。

考虑三目运算符：v = *test-expr* ? *then-expr* : *else-expr*;

若用条件跳转的方法编译会类似这样：

```
	if(!test-expr)
		goto falsle;
	v = then-expr;
	goto done;
false:
	v = else-expr;
done:
```

也就是说，先根据test-expr的值选择性地计算then-expr或else-expr。但条件传送是先计算再选择赋值的，如：

```
v = then-expr;
ve = else-expr;
t = test-expr;
if (!t) v = ve;
```

其中最后一个赋值语句就是用条件传送实现的。然而，由于使用条件传送时两个expr都会被计算，就可能发生错误，所以它不总是可以使用。

实际上使用条件传送也不总是提高效率。对GCC而言，只有当两个表达式都很容易计算时，它才会使用条件传送。

#### 循环语句

较容易，本质上是往回跳转。

需要注意一下“跳到中间”策略和guarded-do策略。此外对于for循环，有另外的update循环变量部分，对continue语句的编译应当注意这一点，不能跳过update部分。

#### switch语句

本质上是数组跳转。假设针对n进行判断，在开头首先判断n不在case范围内的情况并一步跳转到loc_def，而后根据n计算应该跳转到的跳转表下标。跳转表像是这样：

```
	.section
	.align 8
.L4:
	.quad .L3
	.quad .L8
	.quad .L5
	.quad .L6
	...
```

.quad用于定义一个64位的数据——也就是说跳转表是一系列数据。

关键是领会跳转表是一种非常有效的实现多重分支的方法。

#### 运行时栈

* 对x86-64而言，栈向低地址方向增长，栈指针%rsp减小为分配空间，增大为释放空间。
* 过程需要的存储空间超出寄存器能存放的大小时，就会在栈上分配空间，这个部分称为过程的栈帧。当前正在执行的过程的帧总是在栈顶。
* 过程P调用过程Q时，会把返回的地址压入栈中，以说明Q返回时从P的哪里继续。这个地址为P的栈帧的一部分。
* 若过程需要的存储空间可以由寄存器提供，那就可以不需要栈帧。

#### 转移控制

* call Label或call *Operand：会将PC设定为新过程的代码的起始位置，并将返回地址（call的下一条指令）压入栈中。
* ret：从过程调用中返回，从栈中弹出返回地址，并将PC设置为返回地址。

#### 数据传送

过程间的数据传送大多通过寄存器实现。

x86-64中，通过寄存器最多传递6个整型参数。其顺序：%rdi，%rsi，%rdx，%rcx，%r8，%r9。

超过6个的部分通过栈传递，在过程自己的栈帧中分配空间，使得%rsp往低地址增长，不过在刚执行callq后，返回指针始终在栈顶（因为先分配空间给参数，再call新的过程，同时返回指针入栈）。参数到位后，程序就可以执行call指令，跳转到下一个过程。

#### 调用者保存寄存器

可理解为”调用者负有保存责任“的寄存器。调用者调用新的过程再返回后，这些寄存器的值不能有变。它们包括%rbx，%rbp，%r12~%r15。

而如果新的过程需要用到这些寄存器，就需要使用pushq指令将其入栈，这样之后按顺序popq出栈时，就可以方便地复原这些值。

#### 指针运算

C语言允许对指针进行运算，而计算出来的值会根据该指针引用的数据的大小进行*伸缩*。

##### 嵌套数组

对于声明为T D\[R][C]的数组，它的数组元素D\[i][j]的内存地址为x_D+L(C·i+j)，其中L为数据类型T以字节为单位的大小。

记住此公式即可少费许多脑筋，记住C是后一个参数。

#### 异质数据结构

##### struct

按顺序安排内存。

##### union

以多种类型引用一个对象，也就是说允许这块空间存多种类型的东西。系统会分配其中占据空间最多的类型。里面的东西会互相覆盖，所以比较危险。

一种可用的案例：只有叶子节点有数据的二叉树，可以将左右孩子指针和数据写成一个联合。

##### 数据对齐

指令：.align 8可保证其后面的数据的起始地址是8的倍数，遵守8字节对齐的限制。



### 第2章小炒（无用）

* x位的含义是虚拟地址范围为0~2的x次方-1。关于32位和64位系统对不同类型数据分布字节数见P27。
* 一个字节的值域为0-255，或十六进制的两位，二进制的8位。（这都不会？）

* 大端法、小端法见P29，最低有效字节在最前称小端法。
* 逻辑运算符|| && !只会得到0或1。见P39
* 逻辑右移全填0。见P40
* 移动位数大于数据位数，见P41，要取模。
* 一些数据范围见P42-43
* 补码相关，见P45-46
* 零扩展，见P54。无符号数的零扩展和补码数的符号扩展。
* P56：把short转换为unsigned时，要先改变大小，再完成从有符号到无符号的转换
* 无符号加法：P61
* 补码加法：P63，具体可见下一页，先加（带进位）后截断