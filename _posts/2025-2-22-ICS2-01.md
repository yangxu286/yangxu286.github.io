---
title: ICS2笔记（1）
date: 2025-2-22 11:45:00 +0800
tags: [ICS, Focus]
categories: [ICS]
---

#### 程序员可见的状态

* 16个64位的寄存器
  * 15个程序寄存器
  * 程序计数器（PC）存放当前正在执行指令的地址

* 条件码（CC）（ZF：zero，SF：sign，OF：overflow）
* 状态码（回忆异常控制流）
* 内存

Y86的简化在于只支持同时跑一个程序，不存在多个进程。

之所以列出这些，是因为接下来的lab中我们需要手动模拟它们。

#### Y86指令

具体见书P245。一共有12类。

Y86的一个显著特征在于它的数据只有8字节这一种。

Y86指令所占空间在1-10字节之间。系统从内存中读取它们的时候，可以从第一个字节判断长度。

##### 指令的编码

* 每个寄存器都有一个4位的编码。
* 每个指令都有一个独一无二的功能码。（P247）每条指令的第一个字节表明指令的类型，高4位为代码部分，低4位为功能部分。

##### movq

Y86支持irmovq、rrmovq、mr/rmmovq。换句话说，和x86的一个区别在于不支持比D(rA)更复杂的寻址。

cmov则只支持在寄存器和寄存器之间传输。

##### Jump

x86实行相对地址跳转，但Y86始终是绝对地址跳转。

##### 栈操作

首先，Y86的栈结构和x86一样，地址向下增长。Y86的pushq和popq也和x86类似。

pushq rA：先减小%rsp后存储rA。（和x86一样），pushq %rsp会存储%rsp减小前的值。

popq rA：先读取%rsp到rA后增大%rsp。（和x86一样），popq %rsp相当于movq(%rsp) %rsp，也就是把%rsp设为(%rsp)。（不存在什么增大%rsp了）

##### 伪指令

点开头代表伪指令。.pos 200说明下面的代码从0x200开始。

#### HCL

HCL就是一个c语言格式的式子，如下：
`bool eq = (a && b) || (!a && !b);`

但是和具体c语言的区别还是有的，HCL只是给后面的式子起了一个名字。

位级的小写ab之上有字级的大写AB。HCL中所有的字级信号都声明为int且不指定大小。

##### MUX（多路复用器）

位级的多路复用器：s为1则取a，为0则取b。

字级的多路复用器：一个道理，只不过a和b变成了A和B。

用HCL表达形如：

```
word Min3 = [
	A <= B && A <= C : A;
	B <= A && B <= C : B;
	1				 : C;
]
```

最后一行和`default`是一个意思。

这里面的语句不用互斥，因为最先满足的会直接忽视掉后面的。

##### 集合关系

判断某字是否属于某集合（一种大大便捷的写法，相对于等式）：

```
bool s1 = code in { 2, 3 };
bool s0 = code in { 1, 3 };
```

##### 存储

此处的硬件寄存器要和程序寄存器区分开。

**时钟寄存器**存储单个位或字。As clock **rises**, loads input。

**寄存器文件**不用管内部结构，只要知道：往src里输入寄存器id，延迟后val会输出该寄存器的值；此外往dst里输入寄存器id，val里输入寄存器值，在时钟rise后会更新这个寄存器。

关于随机访问存储器，ppt说得很简单：

![](https://github.com/yangxu286/picx-images-hosting/raw/master/微信截图_20250219170924.3yeobkr76f.webp)